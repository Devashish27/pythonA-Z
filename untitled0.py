# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1JXmLTVVLgg-llyfqwfPS6Ex5fu-vZMce
"""

# x = 17
# r = x % 2

# if r==0:
#   print("Will meet")
#   if x > 5:
#     print("Great!")
#   else:
#     print("You are smart")

# else:
# # if r==1:
#   print('Not Interested')

# print("Cya")

# USing elif:
x = 7

if x == 1:
  print('one')

elif x == 2:
  print('two')

elif x == 3:
  print('three')

elif x == 4:
  print('four')

else:
  print('Wrong Input')

# While loop
i = 1
# j = 1

while i <= 5:
# while i >= 1:
  # print("City Hunter! ", i)
  print("City Hunter! ", end="")
  
  j = 1
  while j <= 4:
    print("Always-Legend ", end="")
    j = j + 1

  i = i + 1
  # i = i - 1
  print()

# For loop
# x = ['Pauli', 28, 4.7]
# x = 'PAULO SAULO'

# print(x)
# for i in x:
# for i in [2, 57.6, 'Tyron']:
# for i in range(10):
# for i in range(11, 21, 2):
# for i in range(20, 11, -1):
for i in range(1, 21):
  if i%5!=0:
    print(i)

# Break-continue-pass statements..!
# av = 5

# x = int(input('How many candies you want?'))

# i = 1
# while i <= x:
  
#   if i > av:
#     print("Out of stock at moment..!")
#     break

#   print('Candy')
#   i+=1

# print("Bye!!")

# Printing numbers which are divisible by other nums but not with 3's and soon
# for i in range(1, 101):
  
  # if i%3 == 0 or i%5 == 0:
  # skippin those values divisble by 3 and 5..
  # if i%3 == 0 and i%5 == 0:
      
    # continue

  # print(i)

# print('Cya soon')

# Using pass...!
for i in range(1, 101):

  # if (i%2!=0):
  if (i%2==0):
      pass

  else:
        print(i)

print('Cya')

# Revising Break vs Continue vs Pass..!
for i in range(5):

  if i==3:
    # continue
    break
  print("Hello ", i)

  if i==4:
    pass

def fun():
  pass

a = 7

class xyz:
  pass

# Printing Pattern Tutorials..!
# print("# ", end="")
# print("# ", end="")
# print("# ", end="")
# print("# ", end="")

# Instead use loop
# for i in range(4):    # Inshort we used single loop here. 
#   for j in range(4):
#     print("# ", end=" ")

#   print()

# for k in range(4):
#   print("# ", end=" ")

# print()

# for l in range(4):
#   print("# ", end=" ")

# print()

# for m in range(4):
#   print("# ", end=" ")


# Printing right angle traingle
# for i in range(4):    # Inshort we used single loop here. 
#   for j in range(i+1):
#     print("# ", end=" ")

#   print()


# # Printing in reverse right angle traingle..
# for i in range(4):    # Inshort we used single loop here. 
#   for j in range(4-i):
#     print("# ", end=" ")

#   print()


# For printing 1 2 3 4 reverse right angle...!
for i in range(4):    # Inshort we used single loop here. 
  for j in range(4-i):
    print(j+1, end=" ")
    # for k in range(4-j):
    #   print(k, end=" ")
  # print(i, end=" ")

  print()

# For-else loop
nums = [20, 17, 18, 22, 26]  # To check if number is divisible by 5

for num in nums:
  if num % 5 == 0:
    print(num)

# So here if you want to print first number divisible by 5 then use break
    break
else:
    print("Element Not Found")

# Prime Number..!
num = 10

for i in range(2, num):
  if num % i == 0:
    print("Not Prime!!")
    break
else:
  print("Prime!")

# Arrays..!
# To find factorial of given number..!
# import math as m
# a = int(input("Enter your number: "))
# print(m.factorial(a))

# from array import *

# vals = array('i', [5, 9, 8, 4, 2])  # 'i' denotes the small letter of int.

# newArr = array(vals.typecode, (a*a for a in vals))

# i = 0

# while i<len(newArr):
#   print(newArr[i])
#   i+=1


# Code to sort the array in asc order..
from array import *

myarr = [2, 34, 24, 83, 48]

myarr.sort()

print(myarr)

# Array values from user in python...!
# Inserting element in array, searching for element in array.
from array import *

arr = array('i', [])  # Indicating array as int type

n = int(input("Enter the length of the array..!"))

for i in range(n):
  x = int(input("Enter the next value: "))
  arr.append(x)

print(arr)

# Fetching index number..!
val = int(input("Enter the value for search: "))

k = 0
for e in arr:
  if e == val:
      print(k)

      break
      
  k+=1

# By using functions..!
print(arr.index(val))

# Creating array using numpy
from numpy import *

arr = array([1, 2, 3, 2, 5, 7, 8], 'i')

print(arr)

# Various ways to create arrays using numpy
from numpy import *

# arr = array([1, 2, 3, 4, 5], float)
# Using linspace..
# arr = linspace(0, 15, 16)  # Since range is dividing into 16 parts you are getting float value..
# arr = linspace(0, 15)
# arr = arange(1, 15, 2)
# arr = logspace(1, 40, 5)

# print('%2f' %arr[4])

# Zeros() and ones()
# arr = zeros(5)
arr = ones(5, int)  # Converting to int

print(arr)

# Copying an array in python...!
from numpy import *

# arr1 = array([2, 5, 7, 21, 64])
# arr2 = array([6, 2, 1, 3, 7])

# arr = arr + 5

# arr3 = arr1 + arr2

# print(sin(arr1))
# print(log(arr1))
# print(sqrt(arr1))
# print(sum(arr1))
# print(min(arr1))
# print(max(arr1))

# Concatenate two arrays
# print(concatenate([arr1, arr2]))

# Coping array
# arr2 = arr1.view()  # Shallow copy creation
# arr2 = arr1.copy()  # Deep copy creation

# arr1[1] = 24 

# print(arr1)
# print(arr2)

# print(id(arr1))
# print(id(arr2))



# code to add two arrays using for loop.
# import numpy as np
# arr1 = np.array([12, 15, 42, 56, 64])
# arr2 = np.array([22, 35, 48, 98, 78])
# arr1+arr2
 
# new_list = []
# for i in range(max(len(arr1), len(arr2))):
#     new_list.append(arr1[i] + arr2[i])
# new_list



# Code to find max value from an array using in-built function.
arr2 = np.array([22, 35, 48, 98, 78])

print(max(arr2))

# Working with matrix..!
from numpy import *

# arr1 = array([
#               [1, 2, 3, 9, 8, 7],
#               [4, 5, 6, 10, 11, 12]

#             ])

# print(arr1.dtype)  # To know type of data
# print(arr1.ndim)  # To check dimensions of array..
# print(arr1.shape)  # It given rows and columns
# print(arr1.size)

# # To convert 2d into 1d array..!
# arr2 = arr1.flatten()

# arr3 = arr2.reshape(2, 2, 3)  # We can use this to print 2x2 or 3x3 or any shape you want...

# arr1 = array([
#               [1, 2, 3, 4],
#               [5, 6, 7, 8]
#             ])

# For printing into matrixs
# m = matrix(arr1)  

# So for differentiating two rows in arrays
# m = matrix('1 2 3; 4 5 6; 7 8 9')  # If you want multiple rows you can use ';'

# print(diagonal(m))  # To print it into diagonal elements

# To print min and max...
# print(m.min())
# print(m.max())

# Bitwise operators 
m1 = matrix('1 2 3; 6 7 8; 9 10 11')
m2 = matrix('13 35 66; 23 54 25; 65 86 32')

m3 = m1 * m2;

print(m3)

# Whats function and why functions? creating and calling functions...!
# def greet():
#   print("Hello")
#   print("Good Morning!!")

# def add(x, y):
#   c = x + y
#   return c

# result = add(2, 7)
# print(result)

# new function.
def add_sub(x, y):
  c = x+y
  d = x-y
  return c, d

result1, result2 = add_sub(2, 7)
print(result1, result2)

# greet()

# Functional arguments in python...!
# Using pass-by-value and pass-by-ref
def update(lst):
  print(id(lst))
  lst[1] = 27
  print(id(lst))
  print("x ", lst)

lst = [10, 20, 30]
# a = 12
print(id(lst))
update(lst)
print("lst ", lst)

# Types of arguments..!
# def add(a, b):
#   c = a+b
#   print(c)

# add(5, 6)

# def person(name, age=20):
#   print(name)
#   print(age)

# person('tyro', 27)

# By using keywords
# person(age=27, name='tyro')

# person('tyron') # Here if you dont define any age value it will take by default value which is already defined.

# If you define value again then it will take newly derived value
# person('tyron', 30)

# What's variable length..
# def sum(a, *b): # Here * means def multiple values so 'b' is def as tuple..
  # c = a+b
  # print(a)
  # print(b)

  # Here for adding tuple and int
  
  # c = a
  for i in b:
    c = c + i                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 

  print(c)

sum(2, 7, 45, 87)

# Keyword variable length arguments...!  # Date: 06/12/2021  Time: 12:19pm
def person(name, **data):  # Here '*' prints multiple arguments, '**' prints arguments with keywords
  print(name)
  # print(data)

  # Using for loops..!
  for i, j in data.items():
    print(i, j)

person('Tyron', age = 28, city = 'Mumbai', mob = 7395769329)

# Global Keyboard
a = 10
print(id(a))

def something():
  
  a = 12
  print(id(a))

  # For accessing all global variable values we use:
  x = globals()['a']  # Here we are particularly calling value what you need.
  print(id(x))
  # global a  # Specifying 'a' that its a global 

  # a = 7

  print("in func", a)

  # For changing the value you can use globals with value name..
  globals()['a'] = 17

something()

print("outside func", a)

# Passing list to a function..!
def count(lst):
  even = 0
  odd = 0

  for i in lst:
    if i%2 == 0:
      even += 1
    else:
      odd += 1

  return even, odd

lst = [20, 18, 58, 37, 27, 19, 79, 87, 92]

even, odd = count(lst)

# print(even)
# print(odd)

print("Even : {} and odd : {}". format(even, odd))

# Building fibanacci series
# def fib(n):
#   # print(0)
#   # print(1)
# # Using loops now..!
#   a = 0
#   b = 1
  
#   # If you need only single number..
#   if n == 1:
#     print(a)

#   else:
#       print(a)
#       print(b)

#       for i in range(2, n):
        
#         c = a+b
#         a = b
#         b = c
#         print(c)

# fib(7)

# Using while-loop
# def fib(bound):
#     a, b = 0, 1
#     while a < bound:
#         print(a, end="  ")
#         a, b = b, a+b
#     print()

# fib(7)




# if anyone entered value below 0 then you should check if its negative and do all processing..!
# def fib(neg):
#   start = int(input("Enter Your First Number: "))
#   end = int(input("Enter Your Last Number: "))

#   for i in range(start, end+1):

#     if i < 0:
#       print(i, end = " ")

  # else:
  #    a = 0
  #    b = 1
  
    # If you need only single number..
  # if neg == 1:
  #   print(a)

  # else:
  #   print(a)
  #   print(b)

  # for i in range(2, n):
            
  #   c = a+b
  #   a = b
  #   b = c
  #   print(c)

# fib(range(20))



# If someone entered 100 then it should have last number less than 100
def fib(ran):
  
  item = int(input('Enter your number: '))

  a, b = 0, 1

  num = 0

item = int(input('Enter your number: '))

if item <= 0:
  print("Please enter positive numbers!! ")

elif item == 1:
  print("Fib series is upto ", item, ":")

  print(a)

else:
  print("Fib series: ")

  num = 0
  a, b = 0, 1
  
  while num < item:
    print(a)
    c = a + b
    # Updation
    a = b
    b = c
    num += 1

fib(100)

# Factorial..!
def fact(n):
  f = 1

  for i in range(1, n+1):
    f = f * i

  return f

x = 7

result = fact(x)

print(result)

# Recursion..!
import sys

# This is for increasing limit
sys.setrecursionlimit(5000)

print(sys.getrecursionlimit())

i = 0

def greet():
  global i
  i += 1
  print('Hello!!', i)
  greet()

greet()

# Factorial using recursion..!
def fact(n):
  if n == 0:
    return 1

  return n * fact(n - 1)


result = fact(5)

print(result)

# Anonymous functions (Lambda)
f = lambda a, b : a+b

result = f(2, 7)
print(result)

# Filter map reduce..!
# def is_even(n):
#   return n%2 == 0

# def update(n):
#   return n * 2
from functools import reduce

# def add_all(a, b):
#   return a + b

nums = [2, 7, 12, 17, 24, 27, 32]

# Using lambda
# evens = list(filter(is_even, nums))
evens = list(filter(lambda n : n % 2 == 0, nums))

# Mapping...!
doubles = list(map(lambda n : n * 2, evens))

# Using reduce..!
# sum = reduce(add_all, doubles)
sum = reduce(lambda a, b : a + b, doubles)


# print(evens)
print(doubles)
print(sum)

# DECOrators..!
def div(a, b):
  # if a<b:
  #   a, b = b, a
  # return a/b
  print (a/b)

def smart_div(func):
  def inner(a, b):
    if a<b:
      a, b = b, a
    return func(a, b)

  return inner

div = smart_div(div)

div(4, 8)

# Modules...!
a = 2
b = 7

c = add(a, b)

# Body 2 for modules
def add(a, b):
  return a+b

def sub(a, b):
  return a-b
  
def multi(a, b):
  return a*b

def div(a, b):
  return a/b

# class and objects..!
class Computer:

  def __init__(self, cpu, ram):
    self.cpu = cpu
    self.ram = ram

  def config(self):
    print("Config is ", self.cpu, self.ram)

# x = 9
# print(type(x))                                                                                      

# a = '8'
# print(type(a))

com1 = Computer('i5', 'i6')
com2 = Computer('Ryzen 3', 8)

# print(type(com1))

# Computer.config(com1)
# Computer.config(com2)

com1.config()
com2.config()

# a = 5
# a.bit_length()

# Constructor, self and Comparing oBJECTS...!!
class Computer:
  
  def __init__(self):
    self.name = "Tyron"
    self.age = 27
 
  # def update(self):
  #   self.age = 30

  def compare(self, other):
    if self.age == other.age:
      return True
    else:
      return False


c1 = Computer()
c1.age = 29
c2 = Computer()

# if c1 == c2:
if c1.compare(c2):
  print("They are same!!")
else:
  print("They are different!!")

# print(id(c1))
# print(id(c2))

# c1.name = "Avanthika"
# c1.age = 12

# c1.update()

print(c1.name)
print(c2.name)

# Types of Variables..!
class Car:

  # Variables that are defined outside init function are called class variables...!!
  wheels = 4      # These are class name spaces...!

  def __init__(self):
    self.mil = 10           # These are instance name spaces...!
    self.com = 'BMW'

c1 = Car()
c2 = Car()

c1.mil = 8

Car.wheels = 7

print(c1.com, c1.mil, c1.wheels)
print(c2.com, c2.mil, c2.wheels)

# Types of methods..!
class Student:

  school = 'Telsinda'

  def __init__(self, m1, m2, m3):
    self.m1 = m1
    self.m2 = m2
    self.m3 = m3

  def avg(self):
    return (self.m1 + self.m2 + self.m3) / 3

  # def get_m1(self):
  #   r
print(student1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111.info())

# Accessors and Mutators are methods in references

# Inner class..!
class Student:

  def __init__(self, name, rollno):
    self.name = name
    self.rollno = rollno
    self.lap = self.Laptop()

  def show(self):
    print(self.name, self.rollno)
    self.lap.show()

  class Laptop:

    def __init__(self):
      self.brand = 'Lenovo'
      self.cpu = 'i5'
      self.ram = 16

    def show(self):
      print(self.brand, self.cpu, self.ram)

s1 = Student('Tyron', 2)
# s1 = Student('Tyron', 2, 'Hp', 'i5', 8)
s2 = Student('Avanti', 3)

# print(s1.name, s1.rollno)

s1.show()

# lap1 = s1.lap
# lap2 = s2.lap

# print(id(lap1))
# print(id(lap2))

# lap1 = Student.Laptop()

# Inheritance..!
class A:
  def feature1(self):
    print("Feature 1 Working!!")

  def feature2(self):
    print("Feature 2 Working!!")

class B:
  def feature3(self):
    print("Feature 3 Working!!")

  def feature4(self):
    print("Feature 4 Working!!")

class C(A, B):
   def feature5(self):
    print("Feature 5 Working!!")

a1 = A()

a1.feature1()
a1.feature2()

b1 = B()

c1 = C()
c1.

# Constructor in Inheritance...!
class A:

  def __init__(self):
    print("In A Init")

  def feature1(self):
    print("Feature 1-A is working")
  
  def feature2(self):
    print("Feature 2 is working")

class B:
  
  def __init__(self):
    print("In B Init")

  def feature3(self):
    print("Feature 3-B is working")
    
  def feature4(self):
    print("Feature 4 is working")

class C(A, B):

  def __init__(self):
    super().__init__()
    print("In C Init")

  def feat(self):
    super().feature2()

a1 = C()
a1.feat()

# Duck Typing..!
class PyCharm:

  def execute(self):
    print("Compiling")
    print("Running")

class MyEditor():

  def execute(self):
    print("Spell Check")
    print("Convention Check")
    print("Compiling")
    print("Running")

class Laptop:

  def code(self, ide):
    ide.execute()  

ide = MyEditor()

lap1 = Laptop()
lap1.code(ide)

# Operator Overloading..!! Polymorphysm
# a = 5
# b = 7

# for strings..!
# a = '5'
# b = '7'

# print(a + b)

# # print(int.__add__(a, b))
# print(str.__add__(a, b))


# Now coming to operator overloading...!
class Student:

  def __init__(self, m1, m2):
    self.m1 = m1
    self.m2 = m2
    
  def __add__(self, other):
    m1 = self.m1 + other.m1
    m2 = self.m2 + other.m2

    s3 = Student(m1, m2)

    return s3

  def __gt__(self, other):
    r1 = self.m1 + self.m2
    r2 = other.m1 + other.m2

    if r1 > r2:
      print("Return True")
    else:
      print("Return False")

  def __str__(self):
    # return self.m1, self.m2
    return '{} {} '.format(self.m1, self.m2)

s1 = Student(25, 75)
s2 = Student(53, 82)

s3 = s1 + s2  

# print(s3.m1)
# print(s3.m2)

if s1 > s2:
  print("S1 Wins")
else:
  print("S2 Wins")

a = 12
print(a.__str__())

# print(s1.__str__())
print(s1)
print(s2)

# Method overloading and method overriding...!
# Method Overloading..!
# class Student:

#   def __init__(self, m1, m2):
#     self.m1 = m1;
#     self.m2 = m2;

#   def sum(self, a=None, b=None, c=None):
    
#     s = 0

#     if a!=None and b!=None and c!=None:

#       s = a+b+c
    
#     elif a!=None and b!=None:
#       s = a+b
#     else:
#       s = a

#     return s

# s1 = Student(24, 97)

# print(s1.sum(2, 7))


# Method Overriding...!
class A:

  def show(self):
    print("In A Show")

class B:

  def show(self):
    print("In B shower")
    

a1 = A()
a1.show()

# Abstract Class and Abstract Method...!
from abc import ABC, abstractmethod

class Computer(ABC):
  @abstractmethod
  def process(self):
    pass 

class Laptop(Computer):
  def process(self):
    print("Its Running//!")

# class Whiteboard(Computer):
#   def write(self):
#     print("Its writing!!")

class Programmer:
  def work(self, com):
    print("Solving Bugs")
    com.process()
# com = Computer()
# com2 = Whiteboard()
com1 = Laptop()

# com.process()          
prog1 = Programmer()
prog1.work(com1)

# com1.process()

# Iterators..!
# nums = [7, 8, 9, 2]

# # print(nums[0])

# # for i in nums:
# #   print(i)

# it = iter(nums)
# print(it.__next__())  # For getting first value we use __next__
# # print(it.__next__())
# # print(it.__next__())
# # print(it.__next__())

# print(next(it))

# for i in nums:
#   print(i)


# Creating new class...!
class TopTen:

  def __init__(self):
    self.num = 1

  def __iter__(self):
    return self

  def __next__(self):

    if self.num <= 10:
      val = self.num
      self.num += 1

      return val
    else:
      raise StopIteration

values = TopTen()

print(next(values))

for i in values:
  print(i)

# Generators...!
def topten():

  n = 1

  while n <= 10:
    sq = n * n;
    yield sq
    n += 1
    
  # yield 1  # We can add multiple yield statements...!
  # yield 2
  # yield 3
  # yield 4
  

values = topten()

# print(values.__next__())  # To find iterator we will use next func
# print(values.__next__())

for i in values:
  print(i)

# Exception Handling...!
a = 5
b = 7
# b = 0

try:
  print("Resource Opened!")
  print(a/b)
  k = int(input("Enter a number!!"))
  print(k)

except ZeroDivisionError as e:
  print("Hey, You Cannot Divide A Number By Zero", e)

except ValueError as e:
  print("Invalid Input")

except Exception as e:
  print("Something went wrong!!") 

finally:
  print("Resource Close!")

# print("Bye!!")

# Multithreading..!!
from time import sleep
from threading import *

class Hello(Thread):
  def run(self):
    for i in range(1000):
      print("Hello!!")
      sleep(1)

class Hi(Thread):
  def run(self):
    for i in range(1000):
      print("Hi!!")
      sleep(1)

t1 = Hello()
t2 = Hi()

t1.start()
sleep(0.2)  # To Avoid collisions we used sleep here.
t2.start()

t1.join()
t2.join()  # To Avoid collision by main thread on bye..

print("Bye!")

# Linear search using python...!
# Using while-loop..!
# pos = -1

# def search(list, n):
#   i = 0

#   while i < len(list):
#     if list[i] == n:
#       globals()['pos'] = i
#       # print("Found Here!!")

#       return True;

#     i = i + 1

#   return False;


# list = [2, 7, 12, 17, 24, 27, 32]
# n = 32  

# if search(list, n):
#   print('found at: ',pos + 1)
# else:
#   print("Not Found: ")


# Using for-loop..!
pos = -1
def search(list, n):
 for i in range(len(list)):
  if list[i]==n:
   globals()['pos'] = i
   return True
 return False

list = [5,8,4,6,9,2]
n = 9

if search(list, n):
 print("Found at ",pos+1)
else:
 print("Not Found")

# Binary search..!
pos = -1

def search(list, n):

  l = 0
  u = len(list)-1

  while l <= u:
    mid = (l+u) // 2  # '//' this will give you integer division

    if list[mid] == n:
      globals()['pos'] = mid
      return True
    else:
      if list[mid] < n:
        l = mid + 1
      else:
        u = mid - 1
  return False

list = [2, 12, 59, 75, 29, 92]

n = 101

if search(list, n):
 print("Found at ",pos+1)
else:
 print("Not Found")

# Bubble sort..!
def sort(nums):
  for i in range(len(nums)-1, 0, -1):
    for j in range(i):
      if nums[j] > nums[j + 1]:
        temp = nums[j]
        nums[j] = nums[j+1]
        nums[j+1] = temp


nums = [7, 32, 24, 2, 27, 17, 12]
# [2, 7, 12, 17, 24, 27, 32]

sort(nums)
print(nums)

# Selection Sort...!
def sort(nums):

  for i in range(7):
    minpos = i
    for j in range(i, 7):
      if nums[j] < nums[minpos]:
        minpos = j

    temp = nums[i]
    nums[i] = nums[minpos]
    nums[minpos] = temp

    print(nums)
    
nums = [7, 32, 24, 2, 27, 17, 12]
# [2, 7, 12, 17, 24, 27, 32]

sort(nums)
print(nums)

# Zip Function!!
names = ("Dev", "Arun", "Avanthika", "Ruithika", "Arun")
comps = ("MS", "Google", "FB", "Amazon", "Google")

# zipped = list(zip(names, comps))  # list format
# zipped = set(zip(names, comps))  # Set returns unstructured and removed duplicate values..!
# zipped = dict(zip(names, comps))  # Dictionary format

# Using for loop
zipped = zip(names, comps)

for(a, b) in zipped:
  print(a, b)

# print(zipped)

import re

str = """

What is Lorem Ipsum?

Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.
Why do we use it?

It is a long established fact that a reader will be distracted by the readable content of a page when looking at its layout. The point of using Lorem Ipsum is that it has a more-or-less normal distribution of letters, as opposed to using 'Content here, content here', making it look like readable English. Many desktop publishing packages and web page editors now use Lorem Ipsum as their default model text, and a search for 'lorem ipsum' will uncover many web sites still in their infancy. Various versions have evolved over the years, sometimes by accident, sometimes on purpose (injected humour and the like).

"""

# email = re.findall(r"[0-9a-zA-Z._+%]+@[0-9a-zA-Z._+%]+[.][a-zA-Z.0-9]+", str)
email = re.findall(r'\w+@\S+\w', str)

print(email)

!pip install pyttsx3
import pyttsx3

!pip install sapi5
import sapi5

engine = pyttsx3.init('sapi5')
voices = engine.getProperty('voices')

print(voices[1].id)
engine.setProperty('voice', voices[1].id)


def speak(audio):
    engine.say(audio)
    engine.runAndWait()


if __name__ == "__main__":
    speak("Tyro Is A Beast")